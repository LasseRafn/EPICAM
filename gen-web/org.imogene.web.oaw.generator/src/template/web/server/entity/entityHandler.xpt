«IMPORT core»
«EXTENSION template::CommonFieldUtilExt» 
«EXTENSION template::CommonEntityUtilExt» 


«DEFINE generate(String packageName, String projectName, String applicationType) FOR CardEntity»
«FILE projectName.toLowerCase()+ "/server/handler/" + this.name.toFirstUpper() + "Handler.java"»
package org.imogene.«projectName.toLowerCase()».server.handler;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Set;

import org.imogene.«projectName.toLowerCase()».domain.dao.*;
import org.imogene.«projectName.toLowerCase()».domain.entity.*;
import org.imogene.lib.common.binary.Binary;
import org.imogene.lib.common.constants.CriteriaConstants;
import org.imogene.lib.common.criteria.BasicCriteria;
import org.imogene.lib.common.criteria.ImogConjunction;
import org.imogene.lib.common.criteria.ImogDisjunction;
import org.imogene.lib.common.criteria.ImogJunction;
import org.imogene.lib.common.entity.ImogActor;
import org.imogene.lib.common.entity.ImogBean;
import org.imogene.lib.common.security.ImogBeanFilter;
import org.imogene.web.server.util.FilterFieldsHelper;
import org.imogene.web.server.util.HttpSessionUtil;
import org.imogene.web.server.util.ProfileUtil;
import org.imogene.web.server.handler.HandlerHelper;
«REM»«IF isBinaryFieldPresent(this.groups.fields) -»
import org.imogene.lib.common.binary.Binary;
import org.imogene.lib.common.binary.BinaryDao;
«ENDIF-»«ENDREM»
«IF hasDynamicFields -»
import org.imogene.lib.common.dynamicfields.DynamicFieldInstance;
import org.imogene.lib.common.dynamicfields.DynamicFieldTemplate;
import org.imogene.web.server.handler.DynamicFieldInstanceHandler;
import org.imogene.web.server.handler.DynamicFieldTemplateHandler;
«ENDIF-»
«IF applicationType == "admin" && Actor.isAssignableFrom(metaType)-»
import org.imogene.admin.server.security.SecurityUtils;
«ENDIF-»
import org.springframework.transaction.annotation.Transactional;



/**
 * A data handler for the «name.toFirstUpper()» beans 
 * @author Medes-IMPS
 */
public class «name.toFirstUpper()»Handler {
	
	private «name.toFirstUpper()»Dao dao;
	«REM»«IF isBinaryFieldPresent(this.groups.fields) -»
	/* BinaryDao for Binary Deletion */
	private BinaryDao<Binary> binaryDao;
	«ENDIF-»«ENDREM»
	«REM»«EXPAND declareDaoForForeignKey(this) FOREACH ((Project) eContainer).entities.groups.fields-»«ENDREM»		
	«IF hasDynamicFields -»
	/* Handlers for dynamic field management */
	private DynamicFieldInstanceHandler dynamicFieldValuesHandler;
	private DynamicFieldTemplateHandler dynamicFieldTemplateHandler;
	«ENDIF-»
	«IF name == "TransfertReference" -»
	private PatientDao patientDao ;	
	«ENDIF-»	
	
	private ImogBeanFilter filter;
	private HandlerHelper handlerHelper;
	
	/**
	 * Loads the entity with the specified id
	 * @param entityId the entity id
	 * @return the entity or null
	 */
	@Transactional(readOnly = true)
	public «name.toFirstUpper()» findById(String entityId) {
		return dao.load(entityId);
	}
	
	/**
	 * Loads the entity with the specified id
	 * @param entityId the entity id
	 * @return the entity or null
	 */
	@Transactional(readOnly=true)
	public «name.toFirstUpper()» getById(String entityId) {
		return dao.getById(entityId);
	}
	
	«IF applicationType == "admin" && Actor.isAssignableFrom(metaType)-»
	/**
	 * Saves or updates the entity
	 * @param entity the entity to be saved or updated
	 * @param isNew true if it is a new entity added for the first time.
	 */	
	@Transactional
	public void save(«name.toFirstUpper()» entity, boolean isNew) {
		save(entity, isNew, false);
	}	
	«ENDIF»

	/**
	 * Saves or updates the entity
	 * @param entity the entity to be saved or updated
	 * @param isNew true if it is a new entity added for the first time.
	 «IF applicationType == "admin" && Actor.isAssignableFrom(metaType)-»
	 * @param passwordChanged true if the password has changed
	 «ENDIF-»
	 */	
	@Transactional
	«IF applicationType == "admin" && Actor.isAssignableFrom(metaType)-»
	public void save(«name.toFirstUpper()» entity, boolean isNew, boolean passwordChanged) {	
	«ELSE-»
	public void save(«name.toFirstUpper()» entity, boolean isNew) {	
	«ENDIF-»
		
	    «FOREACH groups.fields AS f-»
	    «IF f.calculationFunctionName!=null && f.calculationFunctionName.length>0 -»
 		entity.«EXPAND template::CommonFieldUtil::setterName FOR f-»(«f.calculationFunctionName-»());   
	    «ENDIF-»
	    «ENDFOREACH-»
	    
		ImogActor actor = HttpSessionUtil.getCurrentUser();
		
		if (entity != null) {
		
			«IF applicationType == "admin" && Actor.isAssignableFrom(metaType)-»
			if(passwordChanged)
				entity.setPassword(SecurityUtils.passwordHashAsBase64(entity.getPassword(), entity.getLogin()));
			«ENDIF-»
			
			handlerHelper.prepare(entity);
			if (entity.getDeleted() != null)
				entity.setDeleted(null);
			
			«IF hasDynamicFields -»
			// manage dynamic fields
			List<DynamicFieldInstance> dfValues = entity.getDynamicFieldValues();
			if (dfValues != null && dfValues.size()>0) {
				for (DynamicFieldInstance dfValue : dfValues) {
					if(dfValue != null) {
						handlerHelper.prepare(dfValue);
					}
				}
			}
			«ENDIF-»
			
			«EXPAND updateChilds("entity") FOREACH groups.fields-»
			
			«EXPAND removeFromParent FOREACH groups.fields-»
		
			dao.saveOrUpdate(entity, isNew);
			
			«IF name == "TransfertReference" -»
			// update CDT list for patient (remove CDT depart and add CDT arrivee)
			Patient patient = entity.getPatient();
			if (patient != null) {
				List<CentreDiagTrait> centresPatient = patient.getCentres();

				CentreDiagTrait centreArrivee = entity.getCDTArrivee();
				CentreDiagTrait centreDepart = entity.getCDTDepart();

				boolean updatePatient = false;
				if (centreDepart!=null && centresPatient.contains(centreDepart)) {
					if(centresPatient.remove(centreDepart))
						updatePatient = true;
				}

				if (centreArrivee!=null && !centresPatient.contains(centreArrivee)) {
					if(centresPatient.add(centreArrivee))
						updatePatient = true;
				}
				
				if(updatePatient)
					patientDao.saveOrUpdate(patient, false);
			}
			«ENDIF-»						
		}
	}
	
	/**
	 * Saves or updates the bean
	 * @param entity the bean to be saved or updated
	 * @param isNew true if it is a new entity added for the first time.
	 */
	@Transactional
	public void save(ImogBean entity, boolean isNew) {
		handlerHelper.save(entity, isNew);
	}	
	
	/**
	 * Lists the entities of type «name.toFirstUpper()»
	 * @param sortProperty the property used to sort the collection
	 * @param sortOrder true for an ascendant sort
	 * @return list of «name.toFirstLower()»
	 */	
	@Transactional(readOnly=true)
	public List<«name.toFirstUpper()»> list«name.toFirstUpper()»(String sortProperty, boolean sortOrder) {
	
		ImogActor actor = HttpSessionUtil.getCurrentUser();
		ImogJunction junction = createFilterJuntion(actor);	
		
		List<«name.toFirstUpper()»> beans = dao.load(sortProperty, sortOrder, junction);

		return beans;
	}
	
	/**
	 * Lists the entities of type «name.toFirstUpper()»
	 * @param sortProperty the property used to sort the collection
	 * @param sortOrder true for an ascendant sort
	 * @return list of «name.toFirstLower()»
	 */	
	@Transactional(readOnly=true)
	public List<«name.toFirstUpper()»> list«name.toFirstUpper()»(String sortProperty, boolean sortOrder, ImogJunction junction) {
	
		List<«name.toFirstUpper()»> beans = dao.load(sortProperty, sortOrder, junction);

		return beans;
	}
	
	«IF name == "OutBox"-»
	/**
	 * Lists the entities of type OutBox
	 * @return list of outBox
	 */
	@Transactional(readOnly = true)
	public List<OutBox> listOutBoxForSMSService() {
		ImogDisjunction criterion = new ImogDisjunction();
		
		BasicCriteria criteriaToSend = new BasicCriteria();
		criteriaToSend.setOperation(CriteriaConstants.STRING_OPERATOR_EQUAL);
		criteriaToSend.setField(OutBox.Columns.STATUT);
		criteriaToSend.setValue(String.valueOf(OutBox.Columns.STATUT_AENVOYER));

		BasicCriteria criteriaError = new BasicCriteria();
		criteriaError.setOperation(CriteriaConstants.STRING_OPERATOR_EQUAL);
		criteriaError.setField(OutBox.Columns.STATUT);
		criteriaError.setValue(String.valueOf(OutBox.Columns.STATUT_ERREUR));

		criterion.add(criteriaToSend);
		criterion.add(criteriaError);

		List<OutBox> beans = dao.load(criterion);

		return beans;
	}
	«ENDIF-»

	/**
	 * Lists the entities of type «name.toFirstUpper()»
	 * @param i first index to retrieve
	 * @param j nb of items to retrieve
	 * @param sortProperty the property used to sort the collection
	 * @param sortOrder true for an ascendant sort
	 * @return list of «name.toFirstLower()»
	 */	
	@Transactional(readOnly=true)
	public List<«name.toFirstUpper()»> list«name.toFirstUpper()»(int i, int j, String sortProperty, boolean sortOrder) {
	
		ImogActor actor = HttpSessionUtil.getCurrentUser();
		ImogJunction junction = createFilterJuntion(actor);	
		
		List<«name.toFirstUpper()»> beans = dao.load(i, j, sortProperty, sortOrder, junction);

		return beans;
	}
	
	/**
	 * Lists the entities of type «name.toFirstUpper()»
	 * @param i first index to retrieve
	 * @param j nb of items to retrieve
	 * @param sortProperty the property used to sort the collection
	 * @param sortOrder true for an ascendant sort
	 * @param criterions request criteria	 
	 * @return list of «name.toFirstLower()»
	 */
	@Transactional(readOnly=true)
	public List<«name.toFirstUpper()»> list«name.toFirstUpper()»(int i, int j, String sortProperty, boolean sortOrder, ImogJunction criterions) {
	
		ImogActor actor = HttpSessionUtil.getCurrentUser();
		ImogJunction junction = createFilterJuntion(actor);
		if(criterions!=null)
			junction.add(criterions);		
		
		List<«name.toFirstUpper()»> beans = dao.load(i, j, sortProperty, sortOrder, junction);

		return beans;		
	}
	
	/**
	 * Lists the entities of type «name.toFirstUpper()»
	 * @param i first index to retrieve
	 * @param j nb of items to retrieve
	 * @param sortProperty the property used to sort the collection
	 * @param sortOrder true for an ascendant sort
	 * @param criterions request criteria	 
	 * @return list of «name.toFirstLower()»
	 */
	@Transactional(readOnly=true)
	public List<«name.toFirstUpper()»> list«name.toFirstUpper()»(int i, int j, String sortProperty, boolean sortOrder, List<BasicCriteria> criterions) {
	
	
		ImogActor actor = HttpSessionUtil.getCurrentUser();
		ImogJunction junction = createFilterJuntion(actor);
		
		ImogJunction junctionForCrit = new ImogConjunction();
		if(criterions!=null) {
			for(BasicCriteria crit:criterions)
				junctionForCrit.add(crit);
		}
		junction.add(junctionForCrit);		
		
		List<«name.toFirstUpper()»> beans = dao.load(i, j, sortProperty, sortOrder, junction);

		return beans;		
	}
	
	/**
	 * Lists the non affected entities of type «name.toFirstUpper()»	
	 * @param i first index to retrieve
	 * @param j nb of items to retrieve
	 * @param sortProperty the property used to sort the collection
	 * @param sortOrder true for an ascendant sort
	 * @param criterion request criteria	 
	 * @param property the property which is not affected
	 * @return list of «name.toFirstLower()»
	 */
	@Transactional(readOnly=true)
	public List<«name.toFirstUpper()»> listNonAffected«name.toFirstUpper()»(int i, int j, String sortProperty, boolean sortOrder, ImogJunction criterions, String property) {
	
		ImogActor actor = HttpSessionUtil.getCurrentUser();
		ImogJunction junction = createFilterJuntion(actor);
		if(criterions!=null)
			junction.add(criterions);

		List<«name.toFirstUpper()»> beans = dao.loadNonAffected(i, j , sortProperty, sortOrder, property, junction);

		return beans;
	}
	
	/**
	 * Lists the non affected entities of type «name.toFirstUpper()»	
	 * @param i first index to retrieve
	 * @param j nb of items to retrieve
	 * @param sortProperty the property used to sort the collection
	 * @param sortOrder true for an ascendant sort
	 * @param property the property which is not affected
	 * @return list of «name.toFirstLower()»
	 */
	@Transactional(readOnly=true)
	public List<«name.toFirstUpper()»> listNonAffected«name.toFirstUpper()»(int i, int j, String sortProperty, boolean sortOrder, String property) {
		return listNonAffected«name.toFirstUpper()»(i, j, sortProperty, sortOrder, null, property);
	}
	
	/**
	 * Used when «name.toFirstUpper()» is involved in a Relation 1 <-> 1 
	 * Association and is the ReverseRelationField of the Relation
	 * Return all instance of «name.toFirstUpper()» non affected
	 * regarding specified property.	
	 * @param i first index to retrieve
	 * @param j nb of items to retrieve
	 * @param sortProperty the property used to sort the collection
	 * @param sortOrder true for an ascendant sort
	 * @param ImogJunction request criteria
	 * @param property the property which is not affected	 
	 * @return list of «name.toFirstLower()»
	 */
	@Transactional(readOnly=true)
	public List<«name.toFirstUpper()»> listNonAffected«name.toFirstUpper()»Reverse(int i, int j, String sortProperty, boolean sortOrder, ImogJunction criterions, String property) {
	
		ImogActor actor = HttpSessionUtil.getCurrentUser();
		ImogJunction junction = createFilterJuntion(actor);
		if(criterions!=null)
			junction.add(criterions);

		List<«name.toFirstUpper()»> beans = dao.loadNonAffectedReverse(i, j , sortProperty, sortOrder, property, junction);

		return beans;
	}	
	
	/**
	 * Used when «name.toFirstUpper()» is involved in a Relation 1 <-> 1 
	 * Association and is the ReverseRelationField of the Relation
	 * Return all instance of «name.toFirstUpper()» non affected
	 * regarding specified property.	
	 * @param i first index to retrieve
	 * @param j nb of items to retrieve
	 * @param sortProperty the property used to sort the collection
	 * @param sortOrder true for an ascendant sort
	 * @param property the property which is not affected	 
	 * @return list of «name.toFirstLower()»
	 */
	@Transactional(readOnly=true)
	public List<«name.toFirstUpper()»> listNonAffected«name.toFirstUpper()»Reverse(int i, int j, String sortProperty, boolean sortOrder, String property) {
		return listNonAffected«name.toFirstUpper()»Reverse(i, j, sortProperty, sortOrder, null, property);
	}
	
	/**
	 * Gets an empty list of «name.toFirstUpper()»	
	 * @return an empty list of «name.toFirstUpper()»
	 */
	@Transactional(readOnly=true)
	public List<«name.toFirstUpper()»> get«name.toFirstUpper()»EmptyList() {
		return new ArrayList<«name.toFirstUpper()»>();
	}	
	
	/**
	 * Counts the number of «name.toFirstLower()» in the database
	 * @return the count
	 */
	@Transactional(readOnly=true)
	public Long count«name.toFirstUpper()»() {			
		return  count«name.toFirstUpper()»(null);
	}

	/**
	 * Counts the number of «name.toFirstLower()» in the database, 
	 * that match the criteria
	 * @return the count
	 */
	@Transactional(readOnly=true)
	public Long count«name.toFirstUpper()»(ImogJunction criterions) {
	
		ImogActor actor = HttpSessionUtil.getCurrentUser();		
		ImogJunction junction = createFilterJuntion(actor);
		if(criterions!=null)
			junction.add(criterions);
			
		return dao.count(junction);
	}
	
	/**
	 * Counts the number of non affected «name.toFirstLower()» entities in the database
	 * @param property the property which is not affected
	 * @param criterion request criteria
	 * @return the count
	 */
	@Transactional(readOnly=true)
	public Long countNonAffected«name.toFirstUpper()»(String property, ImogJunction criterions) {

		ImogActor actor = HttpSessionUtil.getCurrentUser();	
		ImogJunction junction = createFilterJuntion(actor);
		if(criterions!=null)
			junction.add(criterions);

		return dao.countNonAffected(property, junction);
	}
	
	/**
	 * Counts the number of non affected «name.toFirstLower()» entities in the database
	 * @param property the property which is not affected
	 * @return the count
	 */
	@Transactional(readOnly=true)
	public Long countNonAffected«name.toFirstUpper()»(String property) {
		return countNonAffected«name.toFirstUpper()»(property, null);
	}
	
	/**
	 * Counts the number of non affected «name.toFirstLower()» entities in the database
	 * @param property the property which is not affected
	 * @param criterion request criteria
	 * @return the count
	 */
	@Transactional(readOnly=true)
	public Long countNonAffected«name.toFirstUpper()»Reverse(String property, ImogJunction criterions) {

		ImogActor actor = HttpSessionUtil.getCurrentUser();
		ImogJunction junction = createFilterJuntion(actor);
		if (criterions!=null)
			junction.add(criterions);
		return dao.countNonAffectedReverse(property, junction);
	}
	
	/**
	 * Counts the number of non affected «name.toFirstLower()» entities in the database
	 * @param property the property which is not affected
	 * @return the count
	 */
	@Transactional(readOnly=true)
	public Long countNonAffected«name.toFirstUpper()»Reverse(String property) {
		return countNonAffected«name.toFirstUpper()»Reverse(property, null);
	}

	/**
	 * Deletes a group of entities identified by their IDs
	 * @param ids Entities to delete IDs
	 * @return The list of deleted entities IDs
	 */
	@Transactional
	public void delete(Set<«name.toFirstUpper()»> entities) {
		if(entities!=null) {
			for(«name.toFirstUpper()» entity:entities)
				delete(entity);
		}
	}

	/**
	 * Removes the specified entity from the database 
	 * @param entity The entity to be deleted
	 */
	@Transactional
	public void delete(«name.toFirstUpper()» entity) {
	
	   	«REM»«IF isBinaryFieldPresent(this.groups.fields) -»
			«EXPAND deleteAttachedBinaries FOREACH groups.fields-»
		«ENDIF-»«ENDREM»	   
	   «REM»«EXPAND deleteRelationFieldCard1Reference(this) FOREACH ((Project) eContainer).entities.groups.fields-»«ENDREM» 
		handlerHelper.prepareForDelete(entity);
		dao.saveOrUpdate(entity, false);	
	}
	
	/**
	 * Removes the specified bean from the database 
	 * @param entity The bean to be deleted
	 */
	@Transactional
	public void delete(ImogBean entity) {
		handlerHelper.delete(entity);
	}

	/**
	 * Lists the entities of type «name.toFirstUpper()» for the CSV export  
	 */	
	@Transactional(readOnly = true)
	public List<«name.toFirstUpper()»> listForCsv(String sortProperty, boolean sortOrder 
		«EXPAND declareSearchParameter((Project)this.eContainer, "") FOREACH columnFields-»
		) {	
	
		ImogActor actor = HttpSessionUtil.getCurrentUser();
		ImogJunction junction = createFilterJuntion(actor);
		
		«FOREACH columnFields AS c ITERATOR iter -»
		«EXPAND createSearchCriteria((Project)this.eContainer, "") FOR c-»
		«ENDFOREACH -»
		
		List<«name.toFirstUpper()»> beans = dao.load(sortProperty, sortOrder, junction);
		List<«name.toFirstUpper()»> securedBeans = filter.<«name.toFirstUpper()»> toSecure(beans);
		return securedBeans;				
	}		
			
	
	«IF Actor.isAssignableFrom(metaType)-»
	/**
	 * Lists the entities of type «name.toFirstUpper()» that have a given login
	 * @param login the login of the «name.toFirstUpper()»
	 * @return
	 */
	@Transactional(readOnly = true)
	public List<«name.toFirstUpper()»> loadFromLogin(String login) {
		return dao.loadFromLogin(login);
	}
	«ENDIF-»
	
	/**
	 * Creates a junction based on the filter field declarations, for the current actor.
	 * @param actor the current actor
	 */
	private ImogJunction createFilterJuntion(ImogActor actor){
		ImogConjunction filterConjunction = new ImogConjunction();
		if (!ProfileUtil.isAdmin(actor))
			filterConjunction.add(handlerHelper.getNotDeletedFilterCriteria());
		«EXPAND handleFilterField(this.name) FOREACH this.actorFilterFields -»
		return filterConjunction;
	} 
	 
	«IF hasDynamicFields -»
	/**
	 * Saves entity of type DynamicFieldInstance
	 * @param entity the DynamicFieldInstance to be saved or updated
	 * @param isNew true if it is a new entity added for the first time.
	 */
	public void saveDynamicFieldValues(DynamicFieldInstance entity, boolean isNew) {
		dynamicFieldValuesHandler.save(entity, isNew);
	}

	/**
	 * Deletes entity of type DynamicFieldInstance
	 * @param toDelete the DynamicFieldInstance to be deleted
	 */
	public void deleteDynamicFieldValues(DynamicFieldInstance toDelete) {
		dynamicFieldValuesHandler.delete(toDelete);
	}
	
	/**
	 * Activates entity of type DynamicFieldInstance
	 * @param entity the entity to be activated of not
	 * @param activate true if the entity has to be enabled, false if it has to be disabled
	 */
	public void activateDynamicFieldTemplate(DynamicFieldTemplate entity, boolean activate) {
		entity.setIsActivated(activate);
		dynamicFieldTemplateHandler.save(entity, false);
	}
	«ENDIF-»	 

	/**
	 * Setter for bean injection
	 * @param dao the «name.toFirstUpper()» Dao
	 */
	public void setDao(«name.toFirstUpper()»Dao dao) {
		this.dao = dao;
	}
	
	/**
	 * Setter for bean injection
	 * @param imogBeanFilter
	 */
	public void setFilter(ImogBeanFilter filter) {
		this.filter = filter;
	}
	
	/**
	 * Setter for bean injection.
	 * @param helper
	 */
	public void setHandlerHelper(HandlerHelper helper) {
		this.handlerHelper = helper;
	}
	
	«IF name == "TransfertReference" -»
	public void setPatientDao(PatientDao patientDao) {
		this.patientDao = patientDao;
	}	
	«ENDIF-»	
	
	«REM»«IF isBinaryFieldPresent(this.groups.fields) -»

	/**
	 * Setter for bean injection
	 * @param binaryDao the Binary Dao
	 */
	public void setBinaryDao(BinaryDao<Binary> binaryDao) {
		this.binaryDao = binaryDao;
	}
	«ENDIF-»«ENDREM»
	
	«IF hasDynamicFields -»
	/**
	 * Setter for bean injection
	 * @param dynamicFieldValuesHandler the DynamicFieldInstance Handler
	 */
	public void setDynamicFieldValuesHandler(DynamicFieldInstanceHandler dynamicFieldValuesHandler) {
		this.dynamicFieldValuesHandler = dynamicFieldValuesHandler;
	}
	
	/**
	 * Setter for bean injection
	 * @param dynamicFieldTemplateHandler the DynamicFieldTemplateHandler Handler
	 */
	public void setDynamicFieldTemplateHandler(DynamicFieldTemplateHandler dynamicFieldTemplateHandler) {
		this.dynamicFieldTemplateHandler = dynamicFieldTemplateHandler;
	}
	«ENDIF-»
	
	«REM» Calculation of field value «ENDREM»
    «FOREACH groups.fields AS f-»
    «IF f.calculationFunctionName!=null && f.calculationFunctionName.length>0 -» 
   «REM» «PROTECT CSTART '/*' CEND '*/' ID 'calcul' + f.shortName »   «ENDREM»    			   	
	/**
	 * Procedure to calculate the value of the field «f.name»
	 */	
	private «EXPAND template::domain::DaoFieldUtil::entityFieldType FOR f-» «f.calculationFunctionName-»(){	
		«EXPAND template::domain::DaoFieldUtil::entityFieldType FOR f-» result = null;	
		return result;
	}    	 
	«REM» «ENDPROTECT»   «ENDREM» 
    «ENDIF-»
    «ENDFOREACH»
    
    
    «IF name == "Lot" -»
	@Transactional(readOnly = true)
	public Boolean isLotUniqueForCdt(String numero, String cdtId) {
		
		if(cdtId != null) {
			
			if (numero != null && !numero.isEmpty()) {
				ImogJunction junction = new ImogConjunction();
				
				BasicCriteria criteria1 = new BasicCriteria();
				criteria1.setOperation(CriteriaConstants.STRING_OPERATOR_CONTAINS);
				criteria1.setField("numero");
				criteria1.setValue(numero);
				junction.add(criteria1);
				
				BasicCriteria criteria2 = new BasicCriteria();
				criteria2.setOperation(CriteriaConstants.STRING_OPERATOR_CONTAINS);
				criteria2.setField("CDT.id");
				criteria2.setValue(cdtId);
				junction.add(criteria2);

				List<Lot> entities = dao.load(junction);
				if (entities == null || entities.size() == 0)
					return true;
				else
					return false;
			} else
				return false;
		}
		return false;
	}
	«ELSEIF name == "Patient"-»
	@Transactional(readOnly=true)
	public Long countPatientFilteredByCdt(ImogJunction criterions, String cdtId) {
		return dao.countPatientFilteredByCdt(criterions, cdtId);
	}
	
	@Transactional(readOnly=true)
	public List<Patient> listPatientFilteredByCdt(int first, int max, String sortProperty, boolean sortOrder, ImogJunction criterions, String cdtId) {
		return dao.listPatientFilteredByCdt(first, max, sortProperty, sortOrder, criterions, cdtId);
	}			
    «ENDIF-»
	
	«REM»«EXPAND setDaoForForeignKey(this) FOREACH ((Project) eContainer).entities.groups.fields-»«ENDREM»
	
}
«ENDFILE»
«ENDDEFINE»



«REM»---------------------------------------------------- «ENDREM»
«REM»-------------------- RELATION FIELDS---------------- «ENDREM»
«REM»---------------------------------------------------- «ENDREM»

«REM» no affection possible from the reverse side of a one-to-one relation«ENDREM»
«DEFINE removeFromParent FOR FieldEntity-»«ENDDEFINE»
«DEFINE removeFromParent FOR ReverseRelationFieldEntity-»
«IF cardinality==1 && oppositeRelationField.cardinality==1-»
		// no affection possible from the reverse side of a one-to-one relation
		entity.«EXPAND template::CommonFieldUtil::setterName FOR this»(null);
«ENDIF-»
«ENDDEFINE»

«REM» «ENDREM»
«DEFINE updateChilds(String entityName) FOR FieldEntity-»«ENDDEFINE»
«DEFINE updateChilds(String entityName) FOR BinaryField-»
if («entityName».get«name.toFirstUpper()»() != null && «entityName».get«name.toFirstUpper()»().getModified() == null) {
	Binary binary = «entityName».get«name.toFirstUpper()»();
	handlerHelper.prepare(binary);
}			
«ENDDEFINE-»
«DEFINE updateChilds(String entityName) FOR RelationFieldEntity-»
«IF nestedForm-»
	// manage related «name.toFirstLower()»
«IF cardinality==1-»
	«entity.name.toFirstUpper()» «shortName.toLowerCase()» = «entityName».«EXPAND template::CommonFieldUtil::getterName FOR this»();
	if(«shortName.toLowerCase()» != null) {
		handlerHelper.prepare(«shortName.toLowerCase()»);
		«IF entity.nestedFields != null && entity.nestedFields.size > 0-»
			«EXPAND updateChilds(shortName.toLowerCase()) FOREACH entity.nestedFields-»
		«ELSE-»
			«EXPAND updateChilds(shortName.toLowerCase()) FOREACH entity.groups.fields-»
		«ENDIF-»
	}
«ELSE-»
	List<«entity.name.toFirstUpper()»> «shortName.toLowerCase()» = «entityName».«EXPAND template::CommonFieldUtil::getterName FOR this»();
	if («shortName.toLowerCase()» != null) {
		for («entity.name.toFirstUpper()» «shortName.toLowerCase()»Item : «shortName.toLowerCase()») {
			handlerHelper.prepare(«shortName.toLowerCase()»Item);
			«IF entity.nestedFields != null && entity.nestedFields.size > 0-»
				«EXPAND updateChilds(shortName.toLowerCase() + "Item") FOREACH entity.nestedFields-»
			«ELSE-»
				«EXPAND updateChilds(shortName.toLowerCase() + "Item") FOREACH entity.groups.fields-»
			«ENDIF-»			
		}
	}
«ENDIF-»	
«ENDIF-»
«ENDDEFINE»


«REM»---------------------------------------------------- «ENDREM»
«REM»-------------------- FILTER FIELDS ----------------- «ENDREM»
«REM»---------------------------------------------------- «ENDREM»

«REM» Filter field handling «ENDREM»
«DEFINE handleFilterField(String entityName) FOR ActorFilter -»
	«IF actorField!=null-»
	/* add filter field for actor «actorField.parentActor.name.toFirstUpper()» */
	if(actor instanceof «actorField.parentActor.name.toFirstUpper()»){	
		ImogJunction «actorField.name.toFirstLower()»«entityField.name.toFirstUpper()» = new ImogDisjunction();
		List<«entityField.entity.name.toFirstUpper()»> filters = ((«actorField.parentActor.name.toFirstUpper()»)actor).«EXPAND template::CommonFieldUtil::getterName FOR actorField»();
		if(filters!=null && !filters.isEmpty()){
			for(Object «entityField.entity.name.toFirstLower()»:filters){
				BasicCriteria criteria = new BasicCriteria();
				criteria.setOperation(CriteriaConstants.STRING_OPERATOR_EQUAL);
				criteria.setField("«EXPAND template::CommonFieldUtil::propertyName FOR entityField».id");
				criteria.setValue(((«entityField.entity.name.toFirstUpper()»)«entityField.entity.name.toFirstLower()»).getId());
				«actorField.name.toFirstLower()»«entityField.name.toFirstUpper()».add(criteria);
			}
		}else{
			FilterFieldsHelper.addEmptyFilter(«actorField.name.toFirstLower()»«entityField.name.toFirstUpper()»);
		}
		if(«actorField.name.toFirstLower()»«entityField.name.toFirstUpper()».getCriterions()!=null && «actorField.name.toFirstLower()»«entityField.name.toFirstUpper()».getCriterions().size()>0)
			filterConjunction.add(«actorField.name.toFirstLower()»«entityField.name.toFirstUpper()»);
	}
	«ENDIF-»
«ENDDEFINE»


«REM» ----------------------------------------------------------------------------------- «ENDREM»
«REM» ------------------------------     DELETE FOREIGN KEYS      ----------------------- «ENDREM»
«REM» ----------------------------------------------------------------------------------- «ENDREM»


«REM» ------------------------------------------ 
      Declare DAO for foreign key deletion
«REM» ------------------------------------------------«ENDREM»
«DEFINE declareDaoForForeignKey(CardEntity cardEntity) FOR FieldEntity-»«ENDDEFINE»
«DEFINE declareDaoForForeignKey(CardEntity cardEntity) FOR RelationFieldEntity-»
«IF cardEntity.name==this.entity.name -»	
	«IF (this.cardinality == 1 && !(ReverseRelationFieldEntity.isAssignableFrom(this.metaType) && (getOppositeCardinality(this) == 1)))
	|| (this.cardinality != 1 && (getOppositeCardinality(this) != 1))-»	
	/* «this.parentGroup.parentCard.name.toFirstUpper()»Dao for Foreign Key Deletion */	
	private «this.parentGroup.parentCard.name.toFirstUpper()»Dao «this.parentGroup.parentCard.name.toFirstLower()»«this.name.toFirstUpper()»Dao;	
     «ENDIF -»
«ENDIF -»
«ENDDEFINE»
«REM» ------------------------------------------ «ENDREM»

«REM» ------------------------------------------ 
      Set DAO for foreign key deletion
«REM» ------------------------------------------------«ENDREM»
«DEFINE setDaoForForeignKey(CardEntity cardEntity) FOR FieldEntity-»«ENDDEFINE»
«DEFINE setDaoForForeignKey(CardEntity cardEntity) FOR RelationFieldEntity-»
«IF cardEntity.name==this.entity.name -»	
	«IF (this.cardinality == 1 && !(ReverseRelationFieldEntity.isAssignableFrom(this.metaType) && (getOppositeCardinality(this) == 1)))
	|| (this.cardinality != 1 && (getOppositeCardinality(this) != 1))-»	
	/**
	 * Setter for bean injection
	 * @param «this.parentGroup.parentCard.name.toFirstLower()»«this.name.toFirstUpper()»Dao the «this.parentGroup.parentCard.name.toFirstUpper()» Dao
	 */
	public void set«this.parentGroup.parentCard.name.toFirstUpper()»«this.name.toFirstUpper()»Dao(«this.parentGroup.parentCard.name.toFirstUpper()»Dao «this.parentGroup.parentCard.name.toFirstLower()»«this.name.toFirstUpper()»Dao) {
		this.«this.parentGroup.parentCard.name.toFirstLower()»«this.name.toFirstUpper()»Dao = «this.parentGroup.parentCard.name.toFirstLower()»«this.name.toFirstUpper()»Dao;
	}	
     «ENDIF -»
«ENDIF -»
«ENDDEFINE»
«REM» ------------------------------------------ «ENDREM»

«REM» ------------------------------------------ 
      Delete foreign key references
«REM» ------------------------------------------------«ENDREM»
«DEFINE deleteRelationFieldCard1Reference(CardEntity cardEntity) FOR FieldEntity-»«ENDDEFINE»
«DEFINE deleteRelationFieldCard1Reference(CardEntity cardEntity) FOR RelationFieldEntity-»
«IF cardEntity.name==this.entity.name -»	
	«IF this.cardinality == 1 && !(ReverseRelationFieldEntity.isAssignableFrom(this.metaType) && (getOppositeCardinality(this) == 1))-»
	«REM»OK for cardinality==1 with the exception of the reverseRelationField of a 1:1 relation«ENDREM»
		«EXPAND deleteForeignKeyCard1 FOR this-»
	«ELSE -»	
		«IF this.cardinality != 1 && (getOppositeCardinality(this) != 1)-»
			«EXPAND deleteForeignKeyCardN FOR this-»		
		«ENDIF -»	
    «ENDIF -»
«ENDIF -»
«ENDDEFINE»
«REM» ------------------------------------------------«ENDREM»

«DEFINE deleteForeignKeyCard1 FOR FieldEntity-»

		// Delete foreign key reference for field «this.name» of entity «this.parentGroup.parentCard.name»
 
        ImogJunction searchCriterionsFor«this.parentGroup.parentCard.name»«this.name» = new ImogConjunction();
		BasicCriteria criteria«this.parentGroup.parentCard.name»«this.name» = new BasicCriteria();
		criteria«this.parentGroup.parentCard.name»«this.name».setOperation(CriteriaConstants.RELATIONFIELD_OPERATOR_EQUAL);
		criteria«this.parentGroup.parentCard.name»«this.name».setValue(entity.getId());
		criteria«this.parentGroup.parentCard.name»«this.name».setField("«EXPAND template::CommonFieldUtil::propertyName FOR this-».id");
		searchCriterionsFor«this.parentGroup.parentCard.name»«this.name».add(criteria«this.parentGroup.parentCard.name»«this.name»);    

		List<«this.parentGroup.parentCard.name.toFirstUpper()»> resultFor«this.parentGroup.parentCard.name»«this.name» = «this.parentGroup.parentCard.name.toFirstLower()»«this.name.toFirstUpper()»Dao.load("«EXPAND template::CommonFieldUtil::getFirstSortField FOR this.parentGroup.parentCard-»", «EXPAND template::CommonFieldUtil::getFirstSortFieldOrderDirection FOR this.parentGroup.parentCard-»,searchCriterionsFor«this.parentGroup.parentCard.name»«this.name»);
		if (resultFor«this.parentGroup.parentCard.name»«this.name»!=null)
		{
			for («this.parentGroup.parentCard.name.toFirstUpper()» foreignEntity: resultFor«this.parentGroup.parentCard.name»«this.name»)
			{
	          	foreignEntity.setModified(new Date());
	          	foreignEntity.«EXPAND template::CommonFieldUtil::setterName FOR this-»(null);
	          	«this.parentGroup.parentCard.name.toFirstLower()»«this.name.toFirstUpper()»Dao.saveOrUpdate(foreignEntity, false);      
        	}	
		}
«ENDDEFINE»
«REM» ------------------------------------------------«ENDREM»

«DEFINE deleteForeignKeyCardN FOR FieldEntity-»

		// Delete foreign key reference for field «this.name» of entity «this.parentGroup.parentCard.name»
 
		List<«this.parentGroup.parentCard.name.toFirstUpper()»> resultFor«this.parentGroup.parentCard.name»«this.name» = «this.parentGroup.parentCard.name.toFirstLower()»«this.name.toFirstUpper()»Dao
		.loadAffectedCardNProperty("«EXPAND template::CommonFieldUtil::propertyName FOR this-»", entity.getId());
		if (resultFor«this.parentGroup.parentCard.name»«this.name»!=null)
		{
			for («this.parentGroup.parentCard.name.toFirstUpper()» foreignEntity: resultFor«this.parentGroup.parentCard.name»«this.name»)
			{
	          	foreignEntity.setModified(new Date());
	          	foreignEntity.removeFrom«EXPAND template::CommonFieldUtil::propertyName FOR this-»(entity);
	          	«this.parentGroup.parentCard.name.toFirstLower()»«this.name.toFirstUpper()»Dao.saveOrUpdate(foreignEntity, false);      
        	}	
		}
«ENDDEFINE»
«REM» ------------------------------------------------«ENDREM»

«DEFINE deleteAttachedBinaries FOR FieldEntity-»«ENDDEFINE»
«DEFINE deleteAttachedBinaries FOR BinaryField-»
		// Delete attached binary for field «this.name»
		Binary «this.name.toFirstLower()» = entity.«EXPAND template::CommonFieldUtil::getterName FOR this-»();
		if («this.name.toFirstLower()»!=null)
			binaryDao.delete(«this.name.toFirstLower()»);

«ENDDEFINE»


«REM» ************************ «ENDREM»
«DEFINE declareSearchParameter(Project p, String property) FOR FieldEntity-»
		, String «property»«EXPAND template::CommonFieldUtil::propertyName FOR this»
«ENDDEFINE»
«DEFINE declareSearchParameter(Project p, String property) FOR TextField-»
		«IF translatable-»
			«FOREACH p.languages AS l ITERATOR iter-»
		, String «property»«EXPAND template::CommonFieldUtil::propertyName FOR this»_«l.name.toFirstLower()»			
			«ENDFOREACH-»
		«ELSE-»
		, String «property»«EXPAND template::CommonFieldUtil::propertyName FOR this»
		«ENDIF-»
«ENDDEFINE»
«DEFINE declareSearchParameter(Project p, String property) FOR DatesField-»
		, String «property»«EXPAND template::CommonFieldUtil::propertyName FOR this»Before
		, String «property»«EXPAND template::CommonFieldUtil::propertyName FOR this»After
«ENDDEFINE»
«DEFINE declareSearchParameter(Project p, String property) FOR RelationFieldEntity-»
	«IF (cardinality == 1 && getOppositeCardinality(this)!=1) || (cardinality == 1 && MainRelationFieldEntity.isAssignableFrom(this.metaType))-»
	 	«EXPAND declareSearchParameter(p, property + name.toFirstLower() + "_") FOREACH entity.mainFields-»		
	«ENDIF-»
«ENDDEFINE»
«DEFINE declareSearchParameter(Project p, String property) FOR BinaryField-»«ENDDEFINE»


«REM» ************************ «ENDREM»
«DEFINE createSearchCriteria(Project p, String property) FOR FieldEntity-»
		if («property»«EXPAND template::CommonFieldUtil::propertyName FOR this» != null && !«property»«EXPAND template::CommonFieldUtil::propertyName FOR this».isEmpty()) {
			BasicCriteria criteria = new BasicCriteria();
			criteria.setOperation(CriteriaConstants.STRING_OPERATOR_CONTAINS);
			criteria.setField("«property.replaceAll("_", ".")»«EXPAND template::CommonFieldUtil::propertyName FOR this»");
			criteria.setValue(«property»«EXPAND template::CommonFieldUtil::propertyName FOR this»);
			junction.add(criteria);
		}
«ENDDEFINE»
«DEFINE createSearchCriteria(Project p, String property) FOR IntegerField-»
		if («property»«EXPAND template::CommonFieldUtil::propertyName FOR this» != null && !«property»«EXPAND template::CommonFieldUtil::propertyName FOR this».isEmpty()) {
			BasicCriteria criteria = new BasicCriteria();
			criteria.setOperation(CriteriaConstants.INT_OPERATOR_EQUAL);
			criteria.setField("«property.replaceAll("_", ".")»«EXPAND template::CommonFieldUtil::propertyName FOR this»");
			criteria.setValue(«property»«EXPAND template::CommonFieldUtil::propertyName FOR this»);
			junction.add(criteria);
		}
«ENDDEFINE»
«DEFINE createSearchCriteria(Project p, String property) FOR FloatField-»
		if («property»«EXPAND template::CommonFieldUtil::propertyName FOR this» != null && !«property»«EXPAND template::CommonFieldUtil::propertyName FOR this».isEmpty()) {
			BasicCriteria criteria = new BasicCriteria();
			criteria.setOperation(CriteriaConstants.FLOAT_OPERATOR_EQUAL);
			criteria.setField("«property.replaceAll("_", ".")»«EXPAND template::CommonFieldUtil::propertyName FOR this»");
			criteria.setValue(«property»«EXPAND template::CommonFieldUtil::propertyName FOR this»);
			junction.add(criteria);
		}
«ENDDEFINE»
«DEFINE createSearchCriteria(Project p, String property) FOR BooleanField-»
		if («property»«EXPAND template::CommonFieldUtil::propertyName FOR this» != null && !«property»«EXPAND template::CommonFieldUtil::propertyName FOR this».isEmpty()) {
			BasicCriteria criteria = new BasicCriteria();
			criteria.setOperation(CriteriaConstants.BOOLEAN_OPERATOR_EQUAL);
			criteria.setField("«property.replaceAll("_", ".")»«EXPAND template::CommonFieldUtil::propertyName FOR this»");
			criteria.setValue(«property»«EXPAND template::CommonFieldUtil::propertyName FOR this»);
			junction.add(criteria);
		}
«ENDDEFINE»
«DEFINE createSearchCriteria(Project p, String property) FOR TextField-»
		«IF translatable-»
			«FOREACH p.languages AS l ITERATOR iter-»
		if («property»«EXPAND template::CommonFieldUtil::propertyName FOR this»_«l.name.toFirstLower()» != null && !«property»«EXPAND template::CommonFieldUtil::propertyName FOR this»_«l.name.toFirstLower()».isEmpty()) {
			BasicCriteria criteria = new BasicCriteria();
			criteria.setOperation(CriteriaConstants.STRING_OPERATOR_CONTAINS);
			criteria.setField("«property.replaceAll("_", ".")»«EXPAND template::CommonFieldUtil::propertyName FOR this».«l.name.toFirstLower()»");
			criteria.setValue(«property»«EXPAND template::CommonFieldUtil::propertyName FOR this»_«l.name.toFirstLower()»);
			junction.add(criteria);
		}					
			«ENDFOREACH-»
		«ELSE-»
		if («property»«EXPAND template::CommonFieldUtil::propertyName FOR this» != null && !«property»«EXPAND template::CommonFieldUtil::propertyName FOR this».isEmpty()) {
			BasicCriteria criteria = new BasicCriteria();
			criteria.setOperation(CriteriaConstants.STRING_OPERATOR_CONTAINS);
			criteria.setField("«property.replaceAll("_", ".")»«EXPAND template::CommonFieldUtil::propertyName FOR this»");
			criteria.setValue(«property»«EXPAND template::CommonFieldUtil::propertyName FOR this»);
			junction.add(criteria);
		}
		«ENDIF-»
«ENDDEFINE»
«DEFINE createSearchCriteria(Project p, String property) FOR DatesField-»
		if («property»«EXPAND template::CommonFieldUtil::propertyName FOR this»Before != null && !«property»«EXPAND template::CommonFieldUtil::propertyName FOR this»Before.isEmpty()) {
			BasicCriteria criteria = new BasicCriteria();
			criteria.setOperation(CriteriaConstants.DATE_OPERATOR_BEFORE);
			criteria.setField("«property.replaceAll("_", ".")»«EXPAND template::CommonFieldUtil::propertyName FOR this»");
			criteria.setValue(«property»«EXPAND template::CommonFieldUtil::propertyName FOR this»Before);
			junction.add(criteria);
		}
		if («property»«EXPAND template::CommonFieldUtil::propertyName FOR this»After != null && !«property»«EXPAND template::CommonFieldUtil::propertyName FOR this»After.isEmpty()) {
			BasicCriteria criteria = new BasicCriteria();
			criteria.setOperation(CriteriaConstants.DATE_OPERATOR_AFTER);
			criteria.setField("«property.replaceAll("_", ".")»«EXPAND template::CommonFieldUtil::propertyName FOR this»");
			criteria.setValue(«property»«EXPAND template::CommonFieldUtil::propertyName FOR this»After);
			junction.add(criteria);
		}
«ENDDEFINE»
«DEFINE createSearchCriteria(Project p, String property) FOR RelationFieldEntity-»
	«IF (cardinality == 1 && getOppositeCardinality(this)!=1) || (cardinality == 1 && MainRelationFieldEntity.isAssignableFrom(this.metaType))-»
	 	«EXPAND createSearchCriteria(p, property + name.toFirstLower() + "_") FOREACH entity.mainFields-»		
	«ENDIF-»
«ENDDEFINE»
«DEFINE createSearchCriteria(Project p, String property) FOR BinaryField-»«ENDDEFINE»